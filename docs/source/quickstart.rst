QuickStart
==========


现在社会上招人很难，很多现在计算机科学教育真的很糟糕，很难找到一个从头开始了解现代计算机堆栈的人。

.. note::

   这个页面翻译自George Hotz原仓库中的README部分


在晶体管问题上“作弊”
--------------------------


关于 **Transistors(晶体管)** ，我们需要了解一些概念:


* 我们需要描述如何用晶体管构建 `FPGA <https://zh.wikipedia.org/wiki/%E7%8E%B0%E5%9C%BA%E5%8F%AF%E7%BC%96%E7%A8%8B%E9%80%BB%E8%BE%91%E9%97%A8%E9%98%B5%E5%88%97>`_
* `IC(集成电路) <https://zh.wikipedia.org/wiki/%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF>`_ 只是晶体管的集合，他们在一个美丽且可靠的包裹当中
* 了解 `LUT(查找表) <https://en.wikipedia.org/wiki/Lookup_table>`_ 之类的东西


实践性的项目是一个按顺序严格依赖的序列，而这个序列的起点和根基是理论知识本身。在打好理论基础之前，任何实践项目（即使是第一个）都无法真正有效地进行
。因此，当前的首要任务不是急着做项目，而是必须先“谈谈晶体管的理论”。


还有 **Emulation(仿真)** :


在真实的硬件上构建这些东西会限制这个课程的覆盖范围，所以咱们使用 `Verilator <https://verilator.org/guide/latest/>`_ 这种工具让任何人都能在电脑上去玩耍。


硬件用什么来编程
--------------------------


这一章节我们将学习使用 Verilog :


* 闪烁 LED (Verilog, 10) -- 这是你第一个小程序！让模拟器运行起来，并且乘机学习 Verilog 。
* 构建 `UART(通用异步收发传输器) <https://zh.wikipedia.org/zh-cn/UART>`_ -- 这是 Verilog 的一个入门章节，复现一个真实的 UART ，
  介绍 `MMIO(内存映射IO) <https://zh.wikipedia.org/wiki/%E5%AD%98%E5%82%A8%E5%99%A8%E6%98%A0%E5%B0%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA>`_ 的概念，
  尽管串口可能是 semihosting(半主机),串行测试回显程序和LED控制。


处理器到底是什么
--------------------

这一章节我们主要了解什么是CPU : 

* 用python写一个 `assembler <https://en.wikipedia.org/wiki/Assembly_language>`_ (Python,500) -- 简单且乏味的一件事，这一切发生在并行的CPU上。这教会你ARM架构下面的汇编语言。最初只是输出一个二进制文件，但是会在你写了一个Linker（连接器）之后发生改变呢。
* 构建一个ARM7的CPU(Verilog,1500)-- 请将其拆分成几个小章节。
  一个简单的流水线去启动，解码，取指，执行。当前芯片或系统中可用的块 RAM（Block RAM，简称 BRAM）容量有多少？
  需要至少1MB的存储空间，DDR内存实现起来比较困难，所以考虑使用 `SRAM <https://en.wikipedia.org/wiki/Static_random-access_memory>`_ 。同时，这个存储器需要能够进行仿真和综合，以便进行设计和验证。
* 用汇编语言编写一个引导程序(Assembler, 40)，大小为40字节。它被烧录到FPGA镜像中，允许通过串口将代码下载到RAM。这个引导程序可以运行一些简单的测试程序。


编译器是一个高级的语言哦
---------------------------

这一章节我们手搓一个编译器 :

* 构建一个C编译器(用你喜欢的任何语言， 2000) -- 它会涵盖编译器设计的基础知识，并用你喜欢的语言实现一个解析器。最终目标是将代码编译成 ARM 汇编代码。
* 构建一个连接器(Python, 300) --- 如果足够聪明，一天内就能完成。程序的输出格式必须是 `ELF <https://en.wikipedia.org/wiki/Executable_and_Linkable_Format>`_ 文件，
  并且这个程序是用来在 `QEMU <https://en.wikipedia.org/wiki/QEMU>`_ 模拟器中进行测试，并使用半主机（semihosting）功能的。
* 实现 libc 和 malloc (C, 500) -- 它是一个简化版的 libc ，为更底层的编程提供基础。它提供了一些基础函数，例如内存复制、设置和格式化输出，但缺少系统调用接口。
  这意味着它能帮助你构建更复杂的程序，但你需要自己处理与操作系统的交互。
* 写一个以太网控制器(Verilog, 200) -- 老兄你最好和一个硬件工程师谈谈，仔细考虑下MMIO的设计。
* 编写一个引导程序 (C, 300) -- 编写以太网程序，通过 UDP 引导内核。这是用 C 语言编写的第一件事。也许不需要每次都通过串口重新下载，而是嵌入到 FPGA 镜像中。


我们习以为常的操作系统
-------------------------

操作系统逃不开内存管理和文件系统，让我们一探究竟 :


* 写一个 `MMU <https://en.wikipedia.org/wiki/Memory_management_unit>`_ (Verilog, 1000) -- ARM9 风格，解释 TLB 以及其他有趣的东西。
  也许也包括一个内存控制器，取决于 FPGA 的情况，然后将初始化代码添加到你的引导程序中。
* 写一个操作系统(C, 2500) -- Unix 风格，只有用户态线程。(open, read, write, close),
  (fork, execve, wait, sleep, exit), (mmap, munmap, mprotect)这些东西都做一遍。
  考虑。考虑你正在使用的调试接口，从 printf 到可能进入内核的 gdbremote stub。
  分解成子章节一步一步来吧。
* 与 SD 卡通信 (Verilog, 150) -- 你需要做的最后一个硬件。以及一个驱动程序
* FAT(C, 300) -- 这是一个真正的文件系统，我认为FAT是最简单的。
* init, shell, download, cat, ls, rm(C, 250) -- 你的第一个用户空间程序。


浏览器：我们在线了哦
-------------------------


* 构建一个TCP协议栈 (C语言, 500行) -- 可能是内核代码，将以太网驱动集成到内核中。
  为内核添加网络系统调用支持。(send, recv, bind, connect)
* telnetd，多进程的力量 (C, 50) -- 用 C 编写，用户可以通过 telnet 多次连接。实际上就是一个绑定 shell。
* 节省空间的动态链接 (C, 300) -- 因为我们可以，解释一下动态链接器为什么只是一个用户空间程序? 需要对链接器进行修改。
* 关于 web(C, 500+) -- 一个“不错”的基于文本的网页浏览器，使用 ANSI 和终端的友好特性。
  动态链接，而且很棒，你想多棒就有多棒。


物理测试：在真实硬件上运行
---------------------------

买一些硬件回来花不了多少钱 :


* 与 FPGA 通信（C，200）-- 用于 USB MCU 进行 JTAG 位操作的一小段代码。
* FPGA 开发板制作——电路板设计、FPGA BGA 回流焊、FPGA 闪存、50MHz 时钟、USB JTAG 接口和烧录器（无需特殊硬件，只需一个小型 Cypress USB 微控制器即可完成 JTAG）、
  几个 LED、一个复位按钮、一个串口（USB-FTDI，也通过 USB 供电）、一个 SD 卡槽、一个扩展接口（IDE 线缆？）和一个以太网接口。可选：扩展板、主机 USB 接口、NTSC 电视输出接口、ISA 接口以及板载 PS/2 接口（仅供参考）。
  我们提供烤箱和万用表温度计用于回流焊。
* 启动——编译并下载版子上的 Verilog 代码